"use strict";

var enc = encodeURIComponent;
var has = {}.hasOwnProperty;
var apiHost = 'api.sanity.io';
var cdnHost = 'apicdn.sanity.io';

function PicoSanity(config, options) {
  if (!(this instanceof PicoSanity)) {
    return new PicoSanity(config);
  }

  this.clientConfig = config;
  this.fetcher = options.fetch;
  this.headers = options.headers || {};
}

;
['clone', 'create', 'createIfNotExists', 'createOrReplace', 'delete', 'listen', 'mutate', 'patch', 'transaction'].forEach(function (method) {
  PicoSanity.prototype[method] = ni(method);
});

PicoSanity.prototype.config = function (cfg) {
  if (cfg) {
    this.clientConfig = Object.assign({}, this.clientConfig, cfg);
    return this;
  }

  return this.clientConfig;
};

PicoSanity.prototype.fetch = function (query, params, options) {
  var cfg = this.clientConfig;
  var version = cfg.apiVersion ? "v".concat(cfg.apiVersion.replace(/^v/, '')) : 'v1';
  var perspective = options ? options.perspective : cfg.perspective;
  var qsGet = getQs(query, params, {
    perspective: perspective
  });
  var qsPost = !!perspective && perspective !== 'raw' ? "?perspective=".concat(enc(perspective)) : '';
  var usePost = qsGet.length > 11264;
  var qs = usePost ? qsPost : qsGet;
  var auth = cfg.token ? {
    Authorization: "Bearer ".concat(cfg.token)
  } : undefined;
  var type = usePost ? {
    'content-type': 'application/json'
  } : undefined;
  var headers = Object.assign({}, this.headers, auth, type);
  var host = cfg.useCdn ? cdnHost : apiHost;
  var opts = {
    headers: headers,
    method: usePost ? 'POST' : 'GET'
  };

  if (usePost) {
    opts.body = JSON.stringify({
      query: query,
      params: params
    });
  } // Some environments (like CloudFlare Workers) don't support credentials
  // in fetch() RequestInitDict, and there doesn't seem to be any easy way
  // to check of it, so for now we'll make do with a window check :/


  if (typeof window !== 'undefined') {
    opts.credentials = cfg.withCredentials ? 'include' : 'omit';
  }

  var url = "https://".concat(cfg.projectId, ".").concat(host, "/").concat(version, "/data/query/").concat(cfg.dataset).concat(qs);
  return this.fetcher(url, opts).then(parse);
};

function parse(res) {
  var contentType = res.headers.get('content-type') || '';

  if (!contentType.includes('json')) {
    throw getError(res);
  }

  return res.json().then(function (json) {
    if (res.status < 400) {
      return json.result;
    }

    throw getError(res, json);
  });
}

function getError(res, json) {
  var msg = res.url;
  var type = res.statusText;

  if (json && json.error && json.error.description) {
    msg = json.error.description;
    type = json.error.type || type;
  }

  return new Error("HTTP ".concat(res.status, " ").concat(type, ": ").concat(msg));
}

function getQs(query, params, opts) {
  var qs = "?query=".concat(enc(query));

  if (opts.perspective) {
    qs += "&perspective=".concat(enc(opts.perspective));
  }

  if (!params) {
    return qs;
  }

  for (var param in params) {
    if (has.call(params, param)) {
      qs += "&".concat(enc("$".concat(param)), "=").concat(enc(JSON.stringify(params[param])));
    }
  }

  return qs;
}

function ni(method) {
  return function () {
    throw new Error("Method \"".concat(method, "\" not implemented, use @sanity/client"));
  };
}

module.exports = PicoSanity;